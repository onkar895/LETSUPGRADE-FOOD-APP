import { has } from 'ramda';
import { isPlainObject, isString } from 'ramda-adjunct';
import defaultNamespaceInstance from "./namespace.mjs";
import serializeValue from "./serializers/value/index.mjs";
import serializeJSON from "./serializers/json.mjs";
import serializeYAML from "./serializers/yaml-1-2.mjs";
export { dispatchPlugins as dispatchRefractorPlugins } from "./refractor/plugins/utils/index.mjs";
export { default as refractorPluginElementIdentity } from "./refractor/plugins/element-identity.mjs";
export { default as refractorPluginSemanticElementIdentity } from "./refractor/plugins/semantic-element-identity.mjs";
export { default as MediaTypes } from "./media-types.mjs";
export { Element, MemberElement, KeyValuePair, ObjectSlice, ArraySlice, refract } from 'minim';
export { default as namespace, Namespace, createNamespace } from "./namespace.mjs";
export { ObjectElement, ArrayElement, BooleanElement, NullElement, NumberElement, StringElement, LinkElement, RefElement, AnnotationElement, CommentElement, ParseResultElement, SourceMapElement } from "./refractor/registration.mjs";
export { isElement, isStringElement, isNumberElement, isNullElement, isBooleanElement, isArrayElement, isObjectElement, isMemberElement, isLinkElement, isRefElement, isAnnotationElement, isParseResultElement, isSourceMapElement, isPrimitiveElement, hasElementSourceMap, includesSymbols, includesClasses } from "./predicates/index.mjs";
export { default as createPredicate } from "./predicates/helpers.mjs";
export { filter, reject, find, findAtOffset, some, traverse, parents } from "./traversal/index.mjs";
export { visit, BREAK, mergeAllVisitors, getNodeType, keyMapDefault as keyMap } from "./traversal/visitor.mjs";
export { transclude, default as Transcluder } from "./transcluder/index.mjs";
export { dereference } from "./util.mjs";
/**
 * Transforms data to an Element from a particular namespace.
 */
export const from = (data, namespace = defaultNamespaceInstance) => {
  if (isString(data)) {
    // JSON serialized refract
    try {
      return namespace.fromRefract(JSON.parse(data));
    } catch {
      // noop
    }
  }
  if (isPlainObject(data) && has('element', data)) {
    // refract javascript structure
    return namespace.fromRefract(data);
  }
  return namespace.toElement(data);
};

/**
 * Transforms the ApiDOM into JavaScript POJO.
 * This POJO would be the result of interpreting the ApiDOM
 * into JavaScript structure.
 */
export const toValue = serializeValue;

/**
 * Transforms the ApiDOM into JSON string.
 */
export const toJSON = serializeJSON;

/**
 * Transforms the ApiDOM into YAML string.
 */
export const toYAML = serializeYAML;

/**
 * Creates a refract representation of an Element.
 * https://github.com/refractproject/refract-spec
 */
export const dehydrate = (element, namespace = defaultNamespaceInstance) => {
  return namespace.toRefract(element);
};

/**
 * Create a refracted string representation of an Element.
 */
export const toString = (element, namespace = defaultNamespaceInstance) => {
  const refractStructure = dehydrate(element, namespace);
  return JSON.stringify(refractStructure);
};
export { default as sexprs } from "./sexprs.mjs";
export { default as deepmerge } from "./deepmerge.mjs";